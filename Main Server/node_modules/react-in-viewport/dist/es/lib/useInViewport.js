"use strict";

exports.__esModule = true;
exports.default = void 0;

var _react = require("react");

var _reactDom = require("react-dom");

// React hooks
var useInViewport = function useInViewport(target, options, config, props) {
  if (config === void 0) {
    config = {
      disconnectOnLeave: false
    };
  }

  var {
    onEnterViewport,
    onLeaveViewport
  } = props;
  var [inViewport, setInViewport] = (0, _react.useState)(false);
  var [enterCount, setEnterCount] = (0, _react.useState)(0);
  var [leaveCount, setLeaveCount] = (0, _react.useState)(0);
  var observer = (0, _react.useRef)();
  var intersected = (0, _react.useRef)(false);

  function startObserver() {
    if (target.current && observer.current) {
      observer.current.observe((0, _reactDom.findDOMNode)(target.current));
    }
  }

  function stopObserver() {
    if (target.current && observer.current) {
      observer.current.unobserve((0, _reactDom.findDOMNode)(target.current));
      observer.current.disconnect();
      observer.current = null;
    }
  }

  function handleIntersection(entries) {
    var entry = entries[0] || {};
    var {
      isIntersecting,
      intersectionRatio
    } = entry;
    var isInViewport = typeof isIntersecting !== 'undefined' ? isIntersecting : intersectionRatio > 0; // enter

    if (!intersected.current && isInViewport) {
      intersected.current = true;
      onEnterViewport && onEnterViewport();
      setInViewport(isInViewport);
      setEnterCount(enterCount + 1);
      return;
    } // leave


    if (intersected.current && !isInViewport) {
      intersected.current = false;
      onLeaveViewport && onLeaveViewport();

      if (config.disconnectOnLeave && observer.current) {
        // disconnect obsever on leave
        observer.current.disconnect();
      }

      setInViewport(isInViewport);
      setLeaveCount(leaveCount + 1);
    }
  }

  function initIntersectionObserver() {
    if (!observer.current) {
      // $FlowFixMe
      observer.current = new IntersectionObserver(handleIntersection, options);
    }
  }

  (0, _react.useEffect)(() => {
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    initIntersectionObserver();
    startObserver();
    return () => {
      stopObserver();
    };
  }, [target, options, config, onEnterViewport, onLeaveViewport]);
  (0, _react.useEffect)(() => {
    // reset observer on update, to fix race condition that when observer init,
    // the element is not in viewport, such as in animation
    if (!intersected.current && !inViewport) {
      if (observer.current && target.current) {
        observer.current.unobserve((0, _reactDom.findDOMNode)(target.current));
        observer.current.observe((0, _reactDom.findDOMNode)(target.current));
      }
    }
  });
  return {
    inViewport,
    enterCount,
    leaveCount
  };
};

var _default = useInViewport;
exports.default = _default;