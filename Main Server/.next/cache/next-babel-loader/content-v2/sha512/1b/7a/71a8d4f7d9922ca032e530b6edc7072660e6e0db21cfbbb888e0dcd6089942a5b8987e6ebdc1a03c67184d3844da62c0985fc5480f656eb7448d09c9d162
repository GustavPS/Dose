{"ast":null,"code":"import { getLocationOrigin } from 'next/dist/next-server/lib/utils';\n\nconst db = require('../../../lib/db').default;\n\nconst hash = require('./hash');\n\nconst jwt = require('jsonwebtoken');\n\nexport default async function handle(req, res) {\n  if (req.method !== 'POST') {\n    res.status(404).end();\n    return;\n  }\n\n  let username = req.body.username;\n  let password = req.body.password;\n\n  try {\n    let user = await db.any('SELECT password, salt FROM users WHERE username = $1', [username]);\n\n    if (user.length === 0) {\n      res.status(200).json({\n        status: 'error',\n        message: 'Wrong username/password'\n      });\n      return;\n    }\n\n    user = user[0];\n    let salt = user.salt;\n    let hashed = hash.getHash(password, salt);\n    user = await db.any('SELECT * FROM users WHERE username = $1 AND password = $2', [username, hashed]);\n\n    if (user.length === 0) {\n      res.status(200).json({\n        status: 'error',\n        message: 'Wrong username/password'\n      });\n      return;\n    }\n\n    user = user[0];\n    const expiresIn = parseInt(process.env.ACCESS_TOKEN_VALID_TIME);\n    const token = jwt.sign({\n      userId: user.id,\n      email: user.email,\n      username: user.username\n    }, hash.getJWTSecret(), {\n      expiresIn: expiresIn\n    });\n    const validTo = Math.round(Date.now() / 1000 + expiresIn);\n    const refreshToken = hash.generateRefreshToken();\n    const encryptedRefreshToken = hash.getHashWithoutSalt(refreshToken);\n    const encryptedAccessToken = hash.getHashWithoutSalt(token);\n    db.none('INSERT into user_access_token (user_id, access_token, refresh_token) VALUES($1, $2, $3)', [user.id, encryptedAccessToken, encryptedRefreshToken]).then(() => {\n      res.status(200).json({\n        status: 'success',\n        message: 'success',\n        token: token,\n        refreshToken: refreshToken,\n        validTo: validTo\n      });\n    });\n  } catch (e) {\n    console.error(e);\n    res.status(200).json({\n      status: 'error',\n      message: 'Database error'\n    });\n  }\n}\n;","map":{"version":3,"sources":["/mnt/h/Code/Dose/Main Server/pages/api/auth/login.js"],"names":["getLocationOrigin","db","require","default","hash","jwt","handle","req","res","method","status","end","username","body","password","user","any","length","json","message","salt","hashed","getHash","expiresIn","parseInt","process","env","ACCESS_TOKEN_VALID_TIME","token","sign","userId","id","email","getJWTSecret","validTo","Math","round","Date","now","refreshToken","generateRefreshToken","encryptedRefreshToken","getHashWithoutSalt","encryptedAccessToken","none","then","e","console","error"],"mappings":"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","sourcesContent":["import { getLocationOrigin } from 'next/dist/next-server/lib/utils';\r\n\r\nconst db = require('../../../lib/db').default;\r\nconst hash = require('./hash');\r\nconst jwt = require('jsonwebtoken');\r\n\r\nexport default async function handle(req, res) {\r\n    if (req.method !== 'POST') {\r\n        res.status(404).end();\r\n        return;\r\n    }\r\n\r\n    let username = req.body.username;\r\n    let password = req.body.password;\r\n\r\n    try {\r\n        let user = await db.any('SELECT password, salt FROM users WHERE username = $1', [username]);\r\n        if (user.length === 0) {\r\n            res.status(200).json({\r\n                status: 'error',\r\n                message: 'Wrong username/password'\r\n            });\r\n            return;\r\n        }\r\n        user = user[0];\r\n        \r\n        let salt = user.salt;\r\n        let hashed = hash.getHash(password, salt);\r\n        \r\n        user = await db.any('SELECT * FROM users WHERE username = $1 AND password = $2', [username, hashed]);\r\n        if (user.length === 0) {\r\n            res.status(200).json({\r\n                status: 'error',\r\n                message: 'Wrong username/password'\r\n            });\r\n            return;\r\n        }\r\n        user = user[0];\r\n        const expiresIn = parseInt(process.env.ACCESS_TOKEN_VALID_TIME);\r\n        const token = jwt.sign(\r\n            {\r\n                userId: user.id,\r\n                email: user.email,\r\n                username: user.username\r\n            },\r\n            hash.getJWTSecret(),\r\n            {\r\n                expiresIn: expiresIn,\r\n            },\r\n        );\r\n        const validTo = Math.round((Date.now() / 1000) + expiresIn);\r\n\r\n        const refreshToken          = hash.generateRefreshToken();\r\n        const encryptedRefreshToken = hash.getHashWithoutSalt(refreshToken);\r\n        const encryptedAccessToken  = hash.getHashWithoutSalt(token);\r\n\r\n        db.none('INSERT into user_access_token (user_id, access_token, refresh_token) VALUES($1, $2, $3)',[user.id, encryptedAccessToken, encryptedRefreshToken]).then(() => {\r\n            res.status(200).json({\r\n                status: 'success',\r\n                message: 'success',\r\n                token: token,\r\n                refreshToken: refreshToken,\r\n                validTo: validTo\r\n            });\r\n        });\r\n    } catch (e) {\r\n        console.error(e);\r\n        res.status(200).json({\r\n            status: 'error',\r\n            message: 'Database error'\r\n        });\r\n    }\r\n};\r\n\r\n"]},"metadata":{},"sourceType":"module"}