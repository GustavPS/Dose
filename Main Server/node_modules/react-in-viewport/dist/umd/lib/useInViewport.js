(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "react", "react-dom"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("react"), require("react-dom"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.react, global.reactDom);
    global.useInViewport = mod.exports;
  }
})(this, function (_exports, _react, _reactDom) {
  "use strict";

  _exports.__esModule = true;
  _exports["default"] = void 0;

  // React hooks
  var useInViewport = function useInViewport(target, options, config, props) {
    if (config === void 0) {
      config = {
        disconnectOnLeave: false
      };
    }

    var onEnterViewport = props.onEnterViewport,
        onLeaveViewport = props.onLeaveViewport;

    var _useState = (0, _react.useState)(false),
        inViewport = _useState[0],
        setInViewport = _useState[1];

    var _useState2 = (0, _react.useState)(0),
        enterCount = _useState2[0],
        setEnterCount = _useState2[1];

    var _useState3 = (0, _react.useState)(0),
        leaveCount = _useState3[0],
        setLeaveCount = _useState3[1];

    var observer = (0, _react.useRef)();
    var intersected = (0, _react.useRef)(false);

    function startObserver() {
      if (target.current && observer.current) {
        observer.current.observe((0, _reactDom.findDOMNode)(target.current));
      }
    }

    function stopObserver() {
      if (target.current && observer.current) {
        observer.current.unobserve((0, _reactDom.findDOMNode)(target.current));
        observer.current.disconnect();
        observer.current = null;
      }
    }

    function handleIntersection(entries) {
      var entry = entries[0] || {};
      var isIntersecting = entry.isIntersecting,
          intersectionRatio = entry.intersectionRatio;
      var isInViewport = typeof isIntersecting !== 'undefined' ? isIntersecting : intersectionRatio > 0; // enter

      if (!intersected.current && isInViewport) {
        intersected.current = true;
        onEnterViewport && onEnterViewport();
        setInViewport(isInViewport);
        setEnterCount(enterCount + 1);
        return;
      } // leave


      if (intersected.current && !isInViewport) {
        intersected.current = false;
        onLeaveViewport && onLeaveViewport();

        if (config.disconnectOnLeave && observer.current) {
          // disconnect obsever on leave
          observer.current.disconnect();
        }

        setInViewport(isInViewport);
        setLeaveCount(leaveCount + 1);
      }
    }

    function initIntersectionObserver() {
      if (!observer.current) {
        // $FlowFixMe
        observer.current = new IntersectionObserver(handleIntersection, options);
      }
    }

    (0, _react.useEffect)(function () {
      // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
      initIntersectionObserver();
      startObserver();
      return function () {
        stopObserver();
      };
    }, [target, options, config, onEnterViewport, onLeaveViewport]);
    (0, _react.useEffect)(function () {
      // reset observer on update, to fix race condition that when observer init,
      // the element is not in viewport, such as in animation
      if (!intersected.current && !inViewport) {
        if (observer.current && target.current) {
          observer.current.unobserve((0, _reactDom.findDOMNode)(target.current));
          observer.current.observe((0, _reactDom.findDOMNode)(target.current));
        }
      }
    });
    return {
      inViewport: inViewport,
      enterCount: enterCount,
      leaveCount: leaveCount
    };
  };

  var _default = useInViewport;
  _exports["default"] = _default;
});