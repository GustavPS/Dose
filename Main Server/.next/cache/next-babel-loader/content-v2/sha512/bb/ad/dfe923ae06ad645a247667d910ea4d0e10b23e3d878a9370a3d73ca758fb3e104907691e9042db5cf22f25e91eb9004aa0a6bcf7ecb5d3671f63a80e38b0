{"ast":null,"code":"const hash = require('../auth/hash');\n\nconst db = require('../../../lib/db').default;\n\nconst jwt = require('jsonwebtoken');\n\nconst MONTH_IN_SECONDS = 2629743;\nexport default async function handle(req, res) {\n  return new Promise(async resolve => {\n    let token = req.body.token;\n    let refreshToken = req.body.refreshToken;\n    let user = hash.decodeJWT(token, true); // Access token does not exist\n\n    if (!user) {\n      res.status(200).json({\n        status: 'fail',\n        message: 'No match'\n      });\n      resolve();\n      return;\n    }\n\n    let encryptedToken = hash.getHashWithoutSalt(token);\n    let encryptedRefreshToken = hash.getHashWithoutSalt(refreshToken);\n    db.one('SELECT * FROM user_access_token WHERE user_id = $1 AND access_token = $2 AND refresh_token = $3', [user.userId, encryptedToken, encryptedRefreshToken]).then(result => {\n      db.none('DELETE FROM user_access_token WHERE user_id = $1 AND access_token = $2 AND refresh_token = $3', [user.userId, encryptedToken, encryptedRefreshToken]).then(result => {\n        // Check if refresh token has expired\n        const refreshTokenValidTo = user.exp * 1000;\n        const currentDate = Date.now();\n        const secondsSinceExpiry = (currentDate - refreshTokenValidTo) / 1000;\n\n        if (secondsSinceExpiry >= MONTH_IN_SECONDS) {\n          res.status(200).json({\n            status: 'fail',\n            message: 'Refresh token expired'\n          });\n          resolve();\n          return;\n        }\n\n        const expiresIn = parseInt(process.env.ACCESS_TOKEN_VALID_TIME);\n        let newToken = jwt.sign({\n          userId: user.userId,\n          email: user.email,\n          username: user.username\n        }, hash.getJWTSecret(), {\n          expiresIn: expiresIn // 1h\n\n        });\n        const validTo = Math.round(Date.now() / 1000 + expiresIn);\n        refreshToken = hash.generateRefreshToken();\n        encryptedToken = hash.getHashWithoutSalt(newToken);\n        encryptedRefreshToken = hash.getHashWithoutSalt(refreshToken);\n        db.none('INSERT into user_access_token (user_id, access_token, refresh_token) VALUES($1, $2, $3)', [user.userId, encryptedToken, encryptedRefreshToken]).then(() => {\n          res.status(200).json({\n            status: 'success',\n            message: 'success',\n            token: newToken,\n            refreshToken: refreshToken,\n            validTo: validTo\n          });\n          resolve();\n          console.log(\"REFRESHED TOKEN\");\n        });\n      });\n    }).catch(err => {\n      console.log(err); // Pair between access token and refresh token does not exist\n\n      res.status(200).json({\n        status: 'fail',\n        message: 'No match'\n      });\n      resolve();\n    });\n  });\n}\n;","map":{"version":3,"sources":["/mnt/h/Code/Dose/Main Server/pages/api/auth/refreshToken.js"],"names":["hash","require","db","default","jwt","MONTH_IN_SECONDS","handle","req","res","Promise","resolve","token","body","refreshToken","user","decodeJWT","status","json","message","encryptedToken","getHashWithoutSalt","encryptedRefreshToken","one","userId","then","result","none","refreshTokenValidTo","exp","currentDate","Date","now","secondsSinceExpiry","expiresIn","parseInt","process","env","ACCESS_TOKEN_VALID_TIME","newToken","sign","email","username","getJWTSecret","validTo","Math","round","generateRefreshToken","console","log","catch","err"],"mappings":"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","sourcesContent":["const hash = require('../auth/hash');\nconst db = require('../../../lib/db').default;\nconst jwt = require('jsonwebtoken');\n\nconst MONTH_IN_SECONDS = 2629743;\n\nexport default async function handle(req, res) {\n    return new Promise(async (resolve) => {\n        let token = req.body.token;\n        let refreshToken = req.body.refreshToken;\n\n        let user = hash.decodeJWT(token, true);\n\n        // Access token does not exist\n        if (!user) {\n            res.status(200).json({\n                status: 'fail',\n                message: 'No match'\n            });\n            resolve();\n            return;\n        }\n\n        let encryptedToken = hash.getHashWithoutSalt(token);\n        let encryptedRefreshToken = hash.getHashWithoutSalt(refreshToken);\n\n        db.one('SELECT * FROM user_access_token WHERE user_id = $1 AND access_token = $2 AND refresh_token = $3', [user.userId, encryptedToken, encryptedRefreshToken]).then(result => {\n\n            db.none('DELETE FROM user_access_token WHERE user_id = $1 AND access_token = $2 AND refresh_token = $3', [user.userId, encryptedToken, encryptedRefreshToken]).then(result => {\n\n                // Check if refresh token has expired\n                const refreshTokenValidTo = user.exp * 1000;\n                const currentDate = Date.now();\n                const secondsSinceExpiry = (currentDate - refreshTokenValidTo) / 1000;\n                if (secondsSinceExpiry >= MONTH_IN_SECONDS) {\n                    res.status(200).json({\n                        status: 'fail',\n                        message: 'Refresh token expired'\n                    });\n                    resolve();\n                    return;\n                }\n\n                const expiresIn = parseInt(process.env.ACCESS_TOKEN_VALID_TIME);\n                let newToken = jwt.sign(\n                    {\n                        userId: user.userId,\n                        email: user.email,\n                        username: user.username\n                    },\n                    hash.getJWTSecret(),\n                    {\n                        expiresIn: expiresIn, // 1h\n                    },\n                );\n\n                const validTo = Math.round((Date.now() / 1000) + expiresIn);\n\n                refreshToken = hash.generateRefreshToken();\n                encryptedToken = hash.getHashWithoutSalt(newToken);\n                encryptedRefreshToken = hash.getHashWithoutSalt(refreshToken);\n\n                db.none('INSERT into user_access_token (user_id, access_token, refresh_token) VALUES($1, $2, $3)',[user.userId, encryptedToken, encryptedRefreshToken]).then(() => {\n                    res.status(200).json({\n                        status: 'success',\n                        message: 'success',\n                        token: newToken,\n                        refreshToken: refreshToken,\n                        validTo: validTo\n                    });\n                    resolve();\n                    console.log(\"REFRESHED TOKEN\");\n                });\n            });\n        }).catch(err => {\n            console.log(err);\n            // Pair between access token and refresh token does not exist\n            res.status(200).json({\n                status: 'fail',\n                message: 'No match'\n            });\n            resolve();\n        });\n    });\n}; "]},"metadata":{},"sourceType":"module"}