{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"/mnt/h/Code/Dose/Main Server/node_modules/@babel/runtime/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"/mnt/h/Code/Dose/Main Server/node_modules/@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"/mnt/h/Code/Dose/Main Server/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\"));\n\nvar _jsCookie = _interopRequireDefault(require(\"js-cookie\"));\n\nvar _router = _interopRequireDefault(require(\"next/router\"));\n\nvar _lock = _interopRequireDefault(require(\"./lock\"));\n\n// We have to use a lock to avoid race-condition if there are multiple calls to this function at the same time\nvar COOKIE_SETTINGS = {\n  expires: 7\n};\n\nvar validateServerAccess = /*#__PURE__*/function () {\n  var _ref = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(server, cb) {\n    return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _lock[\"default\"].enter( /*#__PURE__*/function () {\n              var _ref2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(token) {\n                var mainAccessToken, mainRefreshToken, mainAccessTokenValidTo, serverAccessToken, serverAccessTokenValidTo, currentTime, mainAccessTokenValid, newTokenInfo, serverAccessTokenValid;\n                return _regenerator[\"default\"].wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        mainAccessToken = _jsCookie[\"default\"].get('token');\n                        mainRefreshToken = _jsCookie[\"default\"].get('refreshToken');\n                        mainAccessTokenValidTo = _jsCookie[\"default\"].get('validTo');\n                        serverAccessToken = _jsCookie[\"default\"].get('serverToken');\n                        serverAccessTokenValidTo = _jsCookie[\"default\"].get('serverValidTo'); // Fail-safe, this should never happen since we check it server-side in _app.js\n\n                        if (mainTokenExist()) {\n                          _context.next = 10;\n                          break;\n                        }\n\n                        console.log(\"Main token does not exist\");\n\n                        _router[\"default\"].push('/');\n\n                        _lock[\"default\"].leave(token);\n\n                        return _context.abrupt(\"return\");\n\n                      case 10:\n                        currentTime = Date.now() / 1000;\n                        mainAccessTokenValid = mainAccessTokenValidTo - currentTime >= 60; // If we have to get a new mainToken\n\n                        if (mainAccessTokenValid) {\n                          _context.next = 28;\n                          break;\n                        }\n\n                        console.log(\"Main token is expired\");\n                        _context.next = 16;\n                        return getNewMainToken(mainAccessToken, mainRefreshToken);\n\n                      case 16:\n                        newTokenInfo = _context.sent;\n                        console.log(newTokenInfo);\n\n                        if (!(newTokenInfo.status === 'success')) {\n                          _context.next = 24;\n                          break;\n                        }\n\n                        console.log(\"Got new main token\");\n                        setMainToken(newTokenInfo.token, newTokenInfo.refreshToken, newTokenInfo.validTo);\n                        mainAccessToken = newTokenInfo.token;\n                        _context.next = 28;\n                        break;\n\n                      case 24:\n                        console.log(\"Couldn't get a new main token\"); // We couldn't get a new token (refresh-token probably too old)\n\n                        _lock[\"default\"].leave(token);\n\n                        _router[\"default\"].push('/');\n\n                        return _context.abrupt(\"return\");\n\n                      case 28:\n                        // If we haven't saved a serverToken\n                        if (!serverTokenExist()) {\n                          console.log(\"No serverToken saved\");\n                          getServerToken(mainAccessToken, server).then(function (result) {\n                            console.log(\"Got a serverToken\"); // We successfully got a new token\n\n                            setServerToken(result.token, result.validTo);\n\n                            _lock[\"default\"].leave(token);\n\n                            cb(result.token);\n                          })[\"catch\"](function (err) {\n                            console.log(\"Couldn't get a serverToken\"); // We couldn't get a new token\n\n                            _lock[\"default\"].leave(token);\n\n                            _router[\"default\"].push('/');\n                          });\n                        } else {\n                          serverAccessTokenValid = serverAccessTokenValidTo - currentTime >= 60; // If we have to get a new serverToken\n\n                          if (!serverAccessTokenValid) {\n                            console.log(\"serverToken was not valid\");\n                            getServerToken(mainAccessToken, server).then(function (result) {\n                              // We successfully got a new token\n                              console.log(\"Got a new serverToken\");\n                              setServerToken(result.token, result.validTo);\n\n                              _lock[\"default\"].leave(token);\n\n                              cb(result.token);\n                            })[\"catch\"](function (err) {\n                              // We couldn't get a new token\n                              console.log(\"Couldn't get a new serverToken\");\n\n                              _lock[\"default\"].leave(token);\n\n                              _router[\"default\"].push('/');\n                            });\n                          } else {\n                            // If we have a valid mainToken and a valid serverToken\n                            _lock[\"default\"].leave(token);\n\n                            cb(serverAccessToken);\n                          }\n                        }\n\n                      case 29:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              }));\n\n              return function (_x3) {\n                return _ref2.apply(this, arguments);\n              };\n            }());\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function validateServerAccess(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar getNewMainToken = /*#__PURE__*/function () {\n  var _ref3 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3(accessToken, refreshToken) {\n    var req, newTokenInfo;\n    return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return fetch(\"\".concat(process.env.NEXT_PUBLIC_SERVER_URL, \"/api/auth/refreshToken\"), {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json'\n              },\n              body: JSON.stringify({\n                token: accessToken,\n                refreshToken: refreshToken\n              })\n            });\n\n          case 2:\n            req = _context3.sent;\n            _context3.next = 5;\n            return req.json();\n\n          case 5:\n            newTokenInfo = _context3.sent;\n            return _context3.abrupt(\"return\", newTokenInfo);\n\n          case 7:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function getNewMainToken(_x4, _x5) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar getServerToken = function getServerToken(mainToken, server) {\n  console.log(server);\n  return new Promise( /*#__PURE__*/function () {\n    var _ref4 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee4(resolve, reject) {\n      return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              fetch(\"\".concat(server.server_ip, \"/api/auth/validate\"), {\n                method: 'POST',\n                headers: {\n                  'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                  token: mainToken\n                })\n              }).then(function (r) {\n                return r.json();\n              }).then(function (data) {\n                if (data.status === 'success') {\n                  resolve({\n                    token: data.token,\n                    validTo: data.validTo\n                  });\n                } else {\n                  console.log(data);\n                  reject();\n                }\n              });\n\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function (_x6, _x7) {\n      return _ref4.apply(this, arguments);\n    };\n  }());\n};\n\nvar serverTokenExist = function serverTokenExist() {\n  var accessToken = _jsCookie[\"default\"].get('serverToken');\n\n  var validTo = _jsCookie[\"default\"].get('serverValidTo');\n\n  return accessToken != null && accessToken != undefined && validTo != null && validTo != undefined;\n};\n\nvar mainTokenExist = function mainTokenExist() {\n  var accessToken = _jsCookie[\"default\"].get('token');\n\n  var refreshToken = _jsCookie[\"default\"].get('refreshToken');\n\n  var validTo = _jsCookie[\"default\"].get('validTo');\n\n  return accessToken != null && accessToken != undefined && refreshToken != null && refreshToken != undefined && validTo != null && validTo != undefined;\n};\n\nvar setServerToken = function setServerToken(token, validTo) {\n  _jsCookie[\"default\"].set('serverToken', token, COOKIE_SETTINGS);\n\n  _jsCookie[\"default\"].set('serverValidTo', validTo, COOKIE_SETTINGS);\n};\n\nvar setMainToken = function setMainToken(token, refreshToken, validTo) {\n  _jsCookie[\"default\"].set('token', token, COOKIE_SETTINGS);\n\n  _jsCookie[\"default\"].set('refreshToken', refreshToken, COOKIE_SETTINGS);\n\n  _jsCookie[\"default\"].set('validTo', validTo, COOKIE_SETTINGS);\n};\n\nmodule.exports = validateServerAccess;","map":{"version":3,"sources":["/mnt/h/Code/Dose/Main Server/lib/validateServerAccess.js"],"names":["COOKIE_SETTINGS","expires","validateServerAccess","server","cb","lock","enter","token","mainAccessToken","cookie","get","mainRefreshToken","mainAccessTokenValidTo","serverAccessToken","serverAccessTokenValidTo","mainTokenExist","console","log","Router","push","leave","currentTime","Date","now","mainAccessTokenValid","getNewMainToken","newTokenInfo","status","setMainToken","refreshToken","validTo","serverTokenExist","getServerToken","then","result","setServerToken","err","serverAccessTokenValid","accessToken","fetch","process","env","NEXT_PUBLIC_SERVER_URL","method","headers","body","JSON","stringify","req","json","mainToken","Promise","resolve","reject","server_ip","r","data","undefined","set","module","exports"],"mappings":"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","sourcesContent":["import cookie from 'js-cookie';\nimport Router from 'next/router';\n// We have to use a lock to avoid race-condition if there are multiple calls to this function at the same time\nimport lock from './lock';\n\nconst COOKIE_SETTINGS = {\n    expires: 7\n}\n\nconst validateServerAccess = async (server, cb) => {\n    lock.enter(async function (token) {\n        let   mainAccessToken          = cookie.get('token');\n        const mainRefreshToken         = cookie.get('refreshToken');\n        const mainAccessTokenValidTo   = cookie.get('validTo');\n        const serverAccessToken        = cookie.get('serverToken');\n        const serverAccessTokenValidTo = cookie.get('serverValidTo');\n    \n        // Fail-safe, this should never happen since we check it server-side in _app.js\n        if (!mainTokenExist()) {\n            console.log(\"Main token does not exist\");\n            Router.push('/');\n            lock.leave(token);\n            return;\n        }\n    \n        const currentTime          = Date.now() / 1000;\n        const mainAccessTokenValid = (mainAccessTokenValidTo - currentTime) >= 60;\n    \n        // If we have to get a new mainToken\n        if (!mainAccessTokenValid) {\n            console.log(\"Main token is expired\");\n            const newTokenInfo = await getNewMainToken(mainAccessToken, mainRefreshToken);\n            console.log(newTokenInfo);\n            if (newTokenInfo.status === 'success') {\n                console.log(\"Got new main token\")\n                setMainToken(newTokenInfo.token, newTokenInfo.refreshToken, newTokenInfo.validTo);\n                mainAccessToken = newTokenInfo.token;\n            } else {\n                console.log(\"Couldn't get a new main token\");\n                // We couldn't get a new token (refresh-token probably too old)\n                lock.leave(token);\n                Router.push('/');\n                return;\n            }\n        }\n    \n        // If we haven't saved a serverToken\n        if (!serverTokenExist()) {\n            console.log(\"No serverToken saved\");\n            getServerToken(mainAccessToken, server)\n            .then(result => {\n                console.log(\"Got a serverToken\");\n                // We successfully got a new token\n                setServerToken(result.token, result.validTo);\n                lock.leave(token);\n                cb(result.token);\n            }).catch(err => {\n                console.log(\"Couldn't get a serverToken\");\n                // We couldn't get a new token\n                lock.leave(token);\n                Router.push('/');\n            });\n        } else {\n            const serverAccessTokenValid = (serverAccessTokenValidTo - currentTime) >= 60;\n            // If we have to get a new serverToken\n            if (!serverAccessTokenValid) {\n                console.log(\"serverToken was not valid\");\n                getServerToken(mainAccessToken, server)\n                .then(result => {\n                    // We successfully got a new token\n                    console.log(\"Got a new serverToken\");\n                    setServerToken(result.token, result.validTo);\n                    lock.leave(token);\n                    cb(result.token);\n                }).catch(err => {\n                    // We couldn't get a new token\n                    console.log(\"Couldn't get a new serverToken\");\n                    lock.leave(token);\n                    Router.push('/');\n                });\n            } else {\n                // If we have a valid mainToken and a valid serverToken\n                lock.leave(token);\n                cb(serverAccessToken);\n            }\n        }\n    });\n\n\n}\n\nconst getNewMainToken = async (accessToken, refreshToken) => {\n    const req = await fetch(`${process.env.NEXT_PUBLIC_SERVER_URL}/api/auth/refreshToken`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            token: accessToken,\n            refreshToken: refreshToken\n        })\n    });\n\n    const newTokenInfo = await req.json();\n    return newTokenInfo;\n}\n\nconst getServerToken = (mainToken, server) => {\n    console.log(server);\n    return new Promise(async (resolve, reject) => {\n        fetch(`${server.server_ip}/api/auth/validate`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({\n                token: mainToken\n            })\n        })\n        .then((r) => r.json())\n        .then((data) => {\n            if (data.status === 'success') {\n                resolve({\n                    token: data.token,\n                    validTo: data.validTo\n                });\n            } else {\n                console.log(data);\n                reject();\n            }\n        });\n    });\n}\n\nconst serverTokenExist = () => {\n    let accessToken  = cookie.get('serverToken');\n    let validTo      = cookie.get('serverValidTo');\n    return accessToken  != null  && accessToken != undefined &&\n           validTo      != null && validTo      != undefined;\n}\n\nconst mainTokenExist = () => {\n    const accessToken  = cookie.get('token');\n    const refreshToken = cookie.get('refreshToken');\n    const validTo      = cookie.get('validTo');\n    return accessToken  != null && accessToken  != undefined &&\n           refreshToken != null && refreshToken != undefined &&\n           validTo      != null && validTo      != undefined;\n}\n\nconst setServerToken = (token, validTo) => {\n    cookie.set('serverToken', token, COOKIE_SETTINGS);\n    cookie.set('serverValidTo', validTo, COOKIE_SETTINGS);\n} \n\nconst setMainToken = (token, refreshToken, validTo) => {\n    cookie.set('token', token, COOKIE_SETTINGS);\n    cookie.set('refreshToken', refreshToken, COOKIE_SETTINGS);\n    cookie.set('validTo', validTo, COOKIE_SETTINGS);\n}\n\nmodule.exports = validateServerAccess;"]},"metadata":{},"sourceType":"script"}