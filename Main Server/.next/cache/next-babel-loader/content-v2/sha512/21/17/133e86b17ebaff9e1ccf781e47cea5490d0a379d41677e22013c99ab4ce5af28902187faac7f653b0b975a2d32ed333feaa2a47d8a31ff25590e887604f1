{"ast":null,"code":"\"use strict\";\n\nvar _jsCookie = _interopRequireDefault(require(\"js-cookie\"));\n\nvar _router = _interopRequireDefault(require(\"next/router\"));\n\nvar _lock = _interopRequireDefault(require(\"./lock\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// We have to use a lock to avoid race-condition if there are multiple calls to this function at the same time\nconst COOKIE_SETTINGS = {\n  expires: 7\n};\n\nconst validateServerAccess = async (server, cb) => {\n  _lock.default.enter(async function (token) {\n    let mainAccessToken = _jsCookie.default.get('token');\n\n    const mainRefreshToken = _jsCookie.default.get('refreshToken');\n\n    const mainAccessTokenValidTo = _jsCookie.default.get('validTo');\n\n    const serverAccessToken = _jsCookie.default.get('serverToken');\n\n    const serverAccessTokenValidTo = _jsCookie.default.get('serverValidTo'); // Fail-safe, this should never happen since we check it server-side in _app.js\n\n\n    if (!mainTokenExist()) {\n      console.log(\"Main token does not exist\");\n\n      _router.default.push('/');\n\n      _lock.default.leave(token);\n\n      return;\n    }\n\n    const currentTime = Date.now() / 1000;\n    const mainAccessTokenValid = mainAccessTokenValidTo - currentTime >= 60; // If we have to get a new mainToken\n\n    if (!mainAccessTokenValid) {\n      console.log(\"Main token is expired\");\n      const newTokenInfo = await getNewMainToken(mainAccessToken, mainRefreshToken);\n      console.log(newTokenInfo);\n\n      if (newTokenInfo.status === 'success') {\n        console.log(\"Got new main token\");\n        setMainToken(newTokenInfo.token, newTokenInfo.refreshToken, newTokenInfo.validTo);\n        mainAccessToken = newTokenInfo.token;\n      } else {\n        console.log(\"Couldn't get a new main token\"); // We couldn't get a new token (refresh-token probably too old)\n\n        _lock.default.leave(token);\n\n        _router.default.push('/');\n\n        return;\n      }\n    } // If we haven't saved a serverToken\n\n\n    if (!serverTokenExist()) {\n      console.log(\"No serverToken saved\");\n      getServerToken(mainAccessToken, server).then(result => {\n        console.log(\"Got a serverToken\"); // We successfully got a new token\n\n        setServerToken(result.token, result.validTo);\n\n        _lock.default.leave(token);\n\n        cb(result.token);\n      }).catch(err => {\n        console.log(\"Couldn't get a serverToken\"); // We couldn't get a new token\n\n        _lock.default.leave(token);\n\n        _router.default.push('/');\n      });\n    } else {\n      const serverAccessTokenValid = serverAccessTokenValidTo - currentTime >= 60; // If we have to get a new serverToken\n\n      if (!serverAccessTokenValid) {\n        console.log(\"serverToken was not valid\");\n        getServerToken(mainAccessToken, server).then(result => {\n          // We successfully got a new token\n          console.log(\"Got a new serverToken\");\n          setServerToken(result.token, result.validTo);\n\n          _lock.default.leave(token);\n\n          cb(result.token);\n        }).catch(err => {\n          // We couldn't get a new token\n          console.log(\"Couldn't get a new serverToken\");\n\n          _lock.default.leave(token);\n\n          _router.default.push('/');\n        });\n      } else {\n        // If we have a valid mainToken and a valid serverToken\n        _lock.default.leave(token);\n\n        cb(serverAccessToken);\n      }\n    }\n  });\n};\n\nconst getNewMainToken = async (accessToken, refreshToken) => {\n  const req = await fetch(`${process.env.NEXT_PUBLIC_SERVER_URL}/api/auth/refreshToken`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      token: accessToken,\n      refreshToken: refreshToken\n    })\n  });\n  const newTokenInfo = await req.json();\n  return newTokenInfo;\n};\n\nconst getServerToken = (mainToken, server) => {\n  console.log(server);\n  return new Promise(async (resolve, reject) => {\n    fetch(`${server.server_ip}/api/auth/validate`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        token: mainToken\n      })\n    }).then(r => r.json()).then(data => {\n      if (data.status === 'success') {\n        resolve({\n          token: data.token,\n          validTo: data.validTo\n        });\n      } else {\n        console.log(data);\n        reject();\n      }\n    });\n  });\n};\n\nconst serverTokenExist = () => {\n  let accessToken = _jsCookie.default.get('serverToken');\n\n  let validTo = _jsCookie.default.get('serverValidTo');\n\n  return accessToken != null && accessToken != undefined && validTo != null && validTo != undefined;\n};\n\nconst mainTokenExist = () => {\n  const accessToken = _jsCookie.default.get('token');\n\n  const refreshToken = _jsCookie.default.get('refreshToken');\n\n  const validTo = _jsCookie.default.get('validTo');\n\n  return accessToken != null && accessToken != undefined && refreshToken != null && refreshToken != undefined && validTo != null && validTo != undefined;\n};\n\nconst setServerToken = (token, validTo) => {\n  _jsCookie.default.set('serverToken', token, COOKIE_SETTINGS);\n\n  _jsCookie.default.set('serverValidTo', validTo, COOKIE_SETTINGS);\n};\n\nconst setMainToken = (token, refreshToken, validTo) => {\n  _jsCookie.default.set('token', token, COOKIE_SETTINGS);\n\n  _jsCookie.default.set('refreshToken', refreshToken, COOKIE_SETTINGS);\n\n  _jsCookie.default.set('validTo', validTo, COOKIE_SETTINGS);\n};\n\nmodule.exports = validateServerAccess;","map":{"version":3,"sources":["/mnt/h/Code/Dose/Main Server/lib/validateServerAccess.js"],"names":["COOKIE_SETTINGS","expires","validateServerAccess","server","cb","lock","enter","token","mainAccessToken","cookie","get","mainRefreshToken","mainAccessTokenValidTo","serverAccessToken","serverAccessTokenValidTo","mainTokenExist","console","log","Router","push","leave","currentTime","Date","now","mainAccessTokenValid","newTokenInfo","getNewMainToken","status","setMainToken","refreshToken","validTo","serverTokenExist","getServerToken","then","result","setServerToken","catch","err","serverAccessTokenValid","accessToken","req","fetch","process","env","NEXT_PUBLIC_SERVER_URL","method","headers","body","JSON","stringify","json","mainToken","Promise","resolve","reject","server_ip","r","data","undefined","set","module","exports"],"mappings":"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","sourcesContent":["import cookie from 'js-cookie';\nimport Router from 'next/router';\n// We have to use a lock to avoid race-condition if there are multiple calls to this function at the same time\nimport lock from './lock';\n\nconst COOKIE_SETTINGS = {\n    expires: 7\n}\n\nconst validateServerAccess = async (server, cb) => {\n    lock.enter(async function (token) {\n        let   mainAccessToken          = cookie.get('token');\n        const mainRefreshToken         = cookie.get('refreshToken');\n        const mainAccessTokenValidTo   = cookie.get('validTo');\n        const serverAccessToken        = cookie.get('serverToken');\n        const serverAccessTokenValidTo = cookie.get('serverValidTo');\n    \n        // Fail-safe, this should never happen since we check it server-side in _app.js\n        if (!mainTokenExist()) {\n            console.log(\"Main token does not exist\");\n            Router.push('/');\n            lock.leave(token);\n            return;\n        }\n    \n        const currentTime          = Date.now() / 1000;\n        const mainAccessTokenValid = (mainAccessTokenValidTo - currentTime) >= 60;\n    \n        // If we have to get a new mainToken\n        if (!mainAccessTokenValid) {\n            console.log(\"Main token is expired\");\n            const newTokenInfo = await getNewMainToken(mainAccessToken, mainRefreshToken);\n            console.log(newTokenInfo);\n            if (newTokenInfo.status === 'success') {\n                console.log(\"Got new main token\")\n                setMainToken(newTokenInfo.token, newTokenInfo.refreshToken, newTokenInfo.validTo);\n                mainAccessToken = newTokenInfo.token;\n            } else {\n                console.log(\"Couldn't get a new main token\");\n                // We couldn't get a new token (refresh-token probably too old)\n                lock.leave(token);\n                Router.push('/');\n                return;\n            }\n        }\n    \n        // If we haven't saved a serverToken\n        if (!serverTokenExist()) {\n            console.log(\"No serverToken saved\");\n            getServerToken(mainAccessToken, server)\n            .then(result => {\n                console.log(\"Got a serverToken\");\n                // We successfully got a new token\n                setServerToken(result.token, result.validTo);\n                lock.leave(token);\n                cb(result.token);\n            }).catch(err => {\n                console.log(\"Couldn't get a serverToken\");\n                // We couldn't get a new token\n                lock.leave(token);\n                Router.push('/');\n            });\n        } else {\n            const serverAccessTokenValid = (serverAccessTokenValidTo - currentTime) >= 60;\n            // If we have to get a new serverToken\n            if (!serverAccessTokenValid) {\n                console.log(\"serverToken was not valid\");\n                getServerToken(mainAccessToken, server)\n                .then(result => {\n                    // We successfully got a new token\n                    console.log(\"Got a new serverToken\");\n                    setServerToken(result.token, result.validTo);\n                    lock.leave(token);\n                    cb(result.token);\n                }).catch(err => {\n                    // We couldn't get a new token\n                    console.log(\"Couldn't get a new serverToken\");\n                    lock.leave(token);\n                    Router.push('/');\n                });\n            } else {\n                // If we have a valid mainToken and a valid serverToken\n                lock.leave(token);\n                cb(serverAccessToken);\n            }\n        }\n    });\n\n\n}\n\nconst getNewMainToken = async (accessToken, refreshToken) => {\n    const req = await fetch(`${process.env.NEXT_PUBLIC_SERVER_URL}/api/auth/refreshToken`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            token: accessToken,\n            refreshToken: refreshToken\n        })\n    });\n\n    const newTokenInfo = await req.json();\n    return newTokenInfo;\n}\n\nconst getServerToken = (mainToken, server) => {\n    console.log(server);\n    return new Promise(async (resolve, reject) => {\n        fetch(`${server.server_ip}/api/auth/validate`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({\n                token: mainToken\n            })\n        })\n        .then((r) => r.json())\n        .then((data) => {\n            if (data.status === 'success') {\n                resolve({\n                    token: data.token,\n                    validTo: data.validTo\n                });\n            } else {\n                console.log(data);\n                reject();\n            }\n        });\n    });\n}\n\nconst serverTokenExist = () => {\n    let accessToken  = cookie.get('serverToken');\n    let validTo      = cookie.get('serverValidTo');\n    return accessToken  != null  && accessToken != undefined &&\n           validTo      != null && validTo      != undefined;\n}\n\nconst mainTokenExist = () => {\n    const accessToken  = cookie.get('token');\n    const refreshToken = cookie.get('refreshToken');\n    const validTo      = cookie.get('validTo');\n    return accessToken  != null && accessToken  != undefined &&\n           refreshToken != null && refreshToken != undefined &&\n           validTo      != null && validTo      != undefined;\n}\n\nconst setServerToken = (token, validTo) => {\n    cookie.set('serverToken', token, COOKIE_SETTINGS);\n    cookie.set('serverValidTo', validTo, COOKIE_SETTINGS);\n} \n\nconst setMainToken = (token, refreshToken, validTo) => {\n    cookie.set('token', token, COOKIE_SETTINGS);\n    cookie.set('refreshToken', refreshToken, COOKIE_SETTINGS);\n    cookie.set('validTo', validTo, COOKIE_SETTINGS);\n}\n\nmodule.exports = validateServerAccess;"]},"metadata":{},"sourceType":"script"}