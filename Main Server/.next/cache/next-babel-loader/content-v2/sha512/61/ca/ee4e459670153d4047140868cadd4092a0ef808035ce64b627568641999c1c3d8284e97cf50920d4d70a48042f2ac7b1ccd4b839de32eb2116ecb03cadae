{"ast":null,"code":"const crypto = require('crypto');\n\nconst jwtSecret = 'SUPERSECRETE20220';\n\nconst jwt = require('jsonwebtoken');\n/**\r\n * generates random string of characters i.e salt\r\n * @function\r\n * @param {number} length - Length of the random string.\r\n */\n\n\nvar genRandomString = function (length) {\n  return crypto.randomBytes(Math.ceil(length / 2)).toString('hex')\n  /** convert to hexadecimal format */\n  .slice(0, length);\n  /** return required number of characters */\n};\n/**\r\n * hash password with sha512.\r\n * @function\r\n * @param {string} password - List of required fields.\r\n * @param {string} salt - Data to be validated.\r\n */\n\n\nvar sha512 = function (password, salt) {\n  var hash = crypto.createHmac('sha512', salt);\n  /** Hashing algorithm sha512 */\n\n  hash.update(password);\n  var value = hash.digest('hex');\n  return value;\n};\n/**\r\n * hash password with sha512.\r\n * @function\r\n * @param {string} string - String to be encrypted\r\n */\n\n\nvar sha512NoSalt = function (string) {\n  var hash = crypto.createHmac('sha512', string);\n  /** Hashing algorithm sha512 */\n\n  var value = hash.digest('hex');\n  return value;\n};\n\nfunction decodeJWT(token, ignoreExpiration = false) {\n  let decoded;\n\n  if (token === undefined || token === null) {\n    return false;\n  }\n\n  try {\n    decoded = jwt.verify(token, jwtSecret, {\n      ignoreExpiration: ignoreExpiration\n    });\n  } catch (e) {\n    console.log(\"error, token gammal? hash.js\");\n  }\n\n  if (decoded) {\n    return decoded;\n  } else {\n    return false;\n  }\n}\n\nfunction getSecret() {\n  return jwtSecret;\n}\n\nfunction generateRefreshToken() {\n  let token = '';\n  let characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  let charactersLength = characters.length;\n  let length = 200;\n\n  for (let i = 0; i < length; i++) {\n    token += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n\n  return token;\n}\n\nfunction generateConnectCode(length = 4) {\n  let token = '';\n  let characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let charactersLength = characters.length;\n\n  for (let i = 0; i < length; i++) {\n    token += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n\n  return token;\n}\n\nexports.getHash = sha512;\nexports.getSalt = genRandomString;\nexports.decodeJWT = decodeJWT;\nexports.getJWTSecret = getSecret;\nexports.generateRefreshToken = generateRefreshToken;\nexports.getHashWithoutSalt = sha512NoSalt;\nexports.generateConnectCode = generateConnectCode;","map":{"version":3,"sources":["/mnt/h/Code/Dose/Main Server/pages/api/auth/hash.js"],"names":["crypto","require","jwtSecret","jwt","genRandomString","length","randomBytes","Math","ceil","toString","slice","sha512","password","salt","hash","createHmac","update","value","digest","sha512NoSalt","string","decodeJWT","token","ignoreExpiration","decoded","undefined","verify","e","console","log","getSecret","generateRefreshToken","characters","charactersLength","i","charAt","floor","random","generateConnectCode","exports","getHash","getSalt","getJWTSecret","getHashWithoutSalt"],"mappings":"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","sourcesContent":["const crypto = require('crypto');\r\nconst jwtSecret = 'SUPERSECRETE20220';\r\nconst jwt = require('jsonwebtoken');\r\n\r\n/**\r\n * generates random string of characters i.e salt\r\n * @function\r\n * @param {number} length - Length of the random string.\r\n */\r\nvar genRandomString = function(length){\r\n    return crypto.randomBytes(Math.ceil(length/2))\r\n            .toString('hex') /** convert to hexadecimal format */\r\n            .slice(0,length);   /** return required number of characters */\r\n}\r\n\r\n/**\r\n * hash password with sha512.\r\n * @function\r\n * @param {string} password - List of required fields.\r\n * @param {string} salt - Data to be validated.\r\n */\r\nvar sha512 = function(password, salt){\r\n    var hash = crypto.createHmac('sha512', salt); /** Hashing algorithm sha512 */\r\n    hash.update(password);\r\n    var value = hash.digest('hex');\r\n    return value;\r\n}\r\n\r\n/**\r\n * hash password with sha512.\r\n * @function\r\n * @param {string} string - String to be encrypted\r\n */\r\n var sha512NoSalt = function(string){\r\n    var hash = crypto.createHmac('sha512', string); /** Hashing algorithm sha512 */\r\n    var value = hash.digest('hex');\r\n    return value;\r\n}\r\n\r\nfunction decodeJWT(token, ignoreExpiration=false) {\r\n    let decoded;\r\n    if (token === undefined || token === null) {\r\n        return false;\r\n    }\r\n\r\n    try {\r\n        decoded = jwt.verify(token, jwtSecret, {\r\n            ignoreExpiration: ignoreExpiration\r\n        });\r\n    } catch (e) {\r\n        console.log(\"error, token gammal? hash.js\")\r\n    }\r\n\r\n    if (decoded) {\r\n        return decoded;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction getSecret() {\r\n    return jwtSecret;\r\n}\r\n\r\nfunction generateRefreshToken() {\r\n    let token           = '';\r\n    let characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n    let charactersLength = characters.length;\r\n    let length = 200;\r\n    for (let i = 0; i < length; i++ ) {\r\n        token += characters.charAt(Math.floor(Math.random() * charactersLength));\r\n    }\r\n    return token;\r\n}\r\n\r\nfunction generateConnectCode(length=4) {\r\n    let token           = '';\r\n    let characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    let charactersLength = characters.length;\r\n    for (let i = 0; i < length; i++ ) {\r\n        token += characters.charAt(Math.floor(Math.random() * charactersLength));\r\n    }\r\n    return token;\r\n}\r\n\r\nexports.getHash = sha512;\r\nexports.getSalt = genRandomString;\r\nexports.decodeJWT = decodeJWT;\r\nexports.getJWTSecret = getSecret;\r\nexports.generateRefreshToken = generateRefreshToken;\r\nexports.getHashWithoutSalt = sha512NoSalt;\r\nexports.generateConnectCode = generateConnectCode;"]},"metadata":{},"sourceType":"script"}